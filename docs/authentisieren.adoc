:imagesdir: ../images
:caution-caption: Achtung
:important-caption: Wichtig
:note-caption: Hinweis
:tip-caption: Tip
:warning-caption: Warnung
ifdef::env-github[]
:imagesdir: https://github.com/gematik/api-erp/raw/master/images
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc: macro
:toclevels: 3
:toc-title: Inhaltsverzeichnis
image:gematik_logo.jpg[width=35%] 

= E-Rezept API-Dokumentation
Hier dokumentiert die gematik die Nutzung der Schnittstellen, um sich mit der Telematikinfrastruktur zu verbinden. Das betrifft zum einen die Authentifizierung als Nutzer oder Institution durch den Identity Provider (IDP) und zum anderen den verschlüsselten Datentransport auf Anwendungsebene (xref:anchor-vau-transport["VAU-Transport]").

toc::[]

= Als Nutzer der Telematikinfrastruktur authentifiziert werden
Die Telematikinfrastruktur gestattet keinen Zugriff auf Dienste ohne eine Identifikation der Nutzer. Dies dient der Durchsetzung von Zugriffsregeln und der Protokollierung des Zugriffs auf medizinische Daten von Versicherten. Mit der Authentifizierung der Nutzer erfolgt keine Profilbildung, Sessiondaten werden temporär verwaltet und nach Beendigung einer Sesssion unverzüglich gelöscht. Die Protokollierung von Zugriffen auf medizinische Daten erfolgt in Abhängigkeit der genutzten Schnittstellen in den jeweils aufgerufenen Services sowie in Abhängigkeit der fachlichen Anforderungen gemäß gematik-Spezifikationen. + 

Die Authentifizierung übernimmt mit der Einführung des E-Rezepts ein zentraler Identity Provider (IDP). Der IDP erkennt Nutzer anhand ihrer kartenbasierten Identitäten und stellt die Identitätsmerkmale (Name, KVNR bzw. Telematik-ID) der Zertifikate auf der Karte in ID_TOKEN und ACCESS_TOKEN für die Nutzung im E-Rezept-Fachdienst bereit.

== Ablauf des Authentifizierungsprotokolls
Leistungserbringerinstitutionen (Praxen, Apotheken, Krankenhäuser) weisen sich gegenüber der Telematikinfrastruktur mit der Identität des Praxisausweises SMC-B aus. Die Authentifizierung erfolgt gegenüber dem Identity Provider (IDP) unter Nutzung der Konnektorschnittstelle.

Das Primärsystem adressiert Anfragen an den IDP über eine bekannt zu machende Adresse *z.B.* `idp.ti-dienste.de`, dabei veröffentlicht der IDP sein DiscoveryDocument mit den Informationen zu verschiedenen Endpunkten zur Tokenausstellung unter einer "/.well-known"-Adresse, d.h. `idp.ti-dienste.de/.well-known/openid-configuration`.

Die folgende Abbildung zeigt den detaillierten Ablauf mit allen beteiligten Komponenten. Das Primärsystem gliedert sich in die E-Rezept-Fachlogik und ein Authenticator-Modul. Letzteres übernimmt die Authentisierung mittels der kartenbasierten Identität unter Nutzung der Konnektorschnittstellen. Der IDP authentifiziert den Nutzer anhand der kartenbasierten Identität und einer Signatur durch das Schlüsselmaterial auf der Karte (SMC-B) und stellt bei Erfolg während der Dauer einer Nutzersession (SSO TOKEN-Gültigkeitsdauer) Zugriffstoken (ACCESS_TOKEN) für den Zugriff auf den Fachdienst aus. 

image:workflowAuthentication.svg[width=100%] 

NOTE: Die Ablaufbeschreibung link:https://gematik.github.io/ref-idp-server/tokenFlowPs.html[Rbelflow für Primärsysteme^] gibt ein konkretes Beispiel mit Request- und Response-Parametern für die Authentifizierung mittels SMC-B einer Test-Apotheke "3-SMC-B-Testkarte-883110000xxxxxx" (siehe auch "professionOID": "1.2.276.0.76.4.54" = "Öffentliche Apotheke").

Die folgenden Schritte sind von besonderer Bedeutung und werden kurz erläutert.

[cols="a,a,a"] 
[cols="1%,1%,100%"]
|===
|*Step*|*eRp (Fachlogik) / AM (Auth-Modul)*|*Beschreibung*
|1 - 4|eRp|Laden der Zertifikatsliste vom FD  [https://erp.zentral.erp.splitdns.ti-dienste.de/CertList] Das root-Zertifikat zu diesen Zertifikaten befindet sich als Vertrauensanker in der App und wird im Build-Prozess eingebracht (Siehe gemSpec_Krypt#7.2). +
Anschließend wird ein code_verifiers (128 zufällige Zeichen aus der Menge [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~") erzeugt und cha256-codiert.
|5 - 13|AM|Laden des Discovery Documents (DD) vom IDP
 [https://idp.zentral.idp.splitdns.ti-dienste.de/.well-known/openid-configuration] *Schritt 1 im Rbel-Flow*, +
Lesen des X509-Signatur-Zertifikats `puk_idp_sig` des IDP von http://url.des.idp/idpSig/jwk.json und IDP-Verschlüsselungsschlüssels `puk_idp_enc` von http://url.des.idp/idpEnc/jwk.json *Schritt 3 + 5 im Rbel-Flow*, +
Prüfung der Signatur des DD gegen das Signatur-Zertifikat im Response-Header x5c und +
Laden und Prüfen der Zertifikate gemäß URI im DD gegen die Zertifikatsliste aus Step 1
|14 - 17|AM|Um die Challenge zu beziehen, wird eine nonce und ein state erzeugt. Nonce ist ein Zufallswert, state kann beliebig gewählt werden, also ebenso eine Zufallszahl oder eine session-id etc. +
Senden der in Schritt 4 generierten code_challenge (als URL-Parameter 'code_challenge') an authorization_endpoint des IDP, der IDP antwortet mit challenge und user_consent +
*Schritt 7 im Rbel-Flow*
|19 - 20|AM|Anzeige user_consent vom IDP und Bestätigung durch den Nutzer, dass die genannten personenbezogenen Attribute vom IDP verarbeitet werden. Die Nutzereinwilligung kann gespeichert werden.
3.+|*Token-Code über Handshake mit Kartenidentität beziehen*
|21|AM|Zertifikat der Authentisierungs-Identität C.AUT von eGK oder SMC-B lesen (siehe unten xref:anchor-read-aut[Konnektor-Aufruf])
|22|AM|Berechnen des HASH-Werts der empfangenen Challenge und Signieren des Challenge-HASH mit PRK.AUT der eGK oder SMC-B (siehe unten xref:anchor-sign-challenge[Konnektor-Aufruf])
|23|AM|jwe-Verschlüsselung der signierten Challenge als njwt und des Zertifikats mit PuK_AUTH_ENC aus jwks
|24|AM|Senden der verschlüsselten Challenge und des verschlüsselten Zertifikats an IDP +
*Schritt 9 im Rbel-Flow* +
|28|AM|Die Response (AuthorizationCode und Redirect zum Tausch AuthorizationCode gegen AccessToken wird an die Fachlogik zurückgegeben [Schritt 41])
|40|AM|Das SSO Token verbleibt im Authenticator.
3.+|*Token-Code über existierendes SessionToken (SSO Token) beziehen*
|29 - 32|AM|Es existiert eine Authentifizierungs-Session ggü. dem IDP, +
die Challenge aus Schritt 17 wird nicht signiert und im Aufruf 1:1 zusammen mit dem SSO Token an den IDP geschickt. +
Die Response (AuthorizationCode und Redirect zum Tausch AuthorizationCode gegen AccessToken wird an die Fachlogik zurückgegeben [Schritt 41])
|40|AM|Das SSO Token verbleibt im Authenticator.
3.+|*Token-Code über eID beziehen (geplant für zukünftige Releases im Zusammenspiel mit der eGK)*
|33|AM|Berechnen des HASH-Werts der empfangenen Challenge und Signieren des Challenge-HASH mit PRK.AUT in SecureElement des Geräts 
|34|AM|jwe-Verschlüsselung der signierten Challenge als njwt und des Zertifikats mit PuK_AUTH_ENC aus jwks und Senden der verschlüsselten Challenge und des verschlüsselten Zertifikats an IDP +
*Schritt 9 im Rbel-Flow* +
|39|AM|Die Response (AuthorizationCode und Redirect zum Tausch AuthorizationCode gegen AccessToken wird an die Fachlogik zurückgegeben [Schritt 41]) +
|40|AM|Das SSO Token verbleibt im Authenticator.
3.+|*Authentifizierung des Nutzers abgeschlossen, im Folgenden wird der AccessToken für den zugriff am E-Rezept-Fachdienst mit Hilfe des AuthorizationCodes abgerufen.*
|42 - 46|eRp|Generierung eines Token-Keys (AES256) zur verschlüsselten Kommunikation mit dem IDP, anschließend wird dem Redirect gefolgt um den AuthorizationCode gegen ein AccessToken zu tauschen.
|47 - 51|AM|Der Aufruf übergebt den zuvor erhaltenen AuthorizationCode und den verschlüsselten Token-Key. +
*Schritt 11 im Rbel-Flow* +
Der IDP prüft seine Signatur des AuthorizationCode, um die Gültigkeit des Codes zu verifizieren und antwortet mit einem verschlüsselten AccessToken für den Zugriff auf den E-Rezept-Fachdienst (und für die E-Rezept-App zusätzlch mit einem verschlüsselten ID_TOKEN, zur Kenntnisnahme der von der eGK genutzten Zertifikatsattribute)
|52 - 56|eRp|Das AccessToken und das ID_TOKEN werden mit Hilfe des Token-Keys entschlüsselt. Das ID_TOKEN verbleibt in der E-Rezept-App (Primärsystemen wird *KEIN* ID_TOKEN ausgestellt), das AccessToken wird in den folgenden Aufrufen zum E-Rezept-Fachdienst zur Authentisierung verwendet.
|===



=== Vorbereitende Schritte für die Authentifizierung mittels der SMC-B
1. Dem Nutzer soll der vom IDP bereitgestellte UserConsent angezeigt werden. Stimmt der Nutzer der Bereitstellung der Daten für den E-Rezept-Fachdienst nicht zu, muss der Authentifizierungsvorgang abgebrochen werden, da der Fachdienst ohne diese Informationen den E-Rezept-Workflow nicht umsetzen kann.
2. Die vom IDP in der obigen Response übermittelte Challenge beinhaltet ein Challenge-Token `{"iss":"https://idp.zentral.idp.splitdns.ti-dienste.de","response_type":"code","snc":"syQAvJmxPnRtLjT6uPVERb_RF7MmVzhS1sP8FbHjhLM","code_challenge_method":"S256","token_type":"challenge","nonce":"887766","client_id":"gematikTestPs","scope":"openid e-rezept","state":"xxxstatexxx","redirect_uri":"http://test-ps.gematik.de/erezept","exp":1616686048,"iat":1616685868,"code_challenge":"Ca3Ve8jSsBQOBFVqQvLs1E-dGV1BXg2FTvrd-Tg19Vg","jti":"5e5ad23ae3e7d8aa"}` in Base64-Codierung `eyJpc3MiOiJodHRwczovL2lkcC56ZW50cmFsLmlkcC5zcGxpdGRucy50aS1kaWVuc3RlLmRlIiwicmVzcG9uc2VfdHlwZSI6ImNvZGUiLCJzbmMiOiJzeVFBdkpteFBuUnRMalQ2dVBWRVJiX1JGN01tVnpoUzFzUDhGYkhqaExNIiwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kIjoiUzI1NiIsInRva2VuX3R5cGUiOiJjaGFsbGVuZ2UiLCJub25jZSI6Ijg4Nzc2NiIsImNsaWVudF9pZCI6ImdlbWF0aWtUZXN0UHMiLCJzY29wZSI6Im9wZW5pZCBlLXJlemVwdCIsInN0YXRlIjoieHh4c3RhdGV4eHgiLCJyZWRpcmVjdF91cmkiOiJodHRwOi8vdGVzdC1wcy5nZW1hdGlrLmRlL2VyZXplcHQiLCJleHAiOjE2MTY2ODYwNDgsImlhdCI6MTYxNjY4NTg2OCwiY29kZV9jaGFsbGVuZ2UiOiJDYTNWZThqU3NCUU9CRlZxUXZMczFFLWRHVjFCWGcyRlR2cmQtVGcxOVZnIiwianRpIjoiNWU1YWQyM2FlM2U3ZDhhYSJ9`. Da die Signatur immer über einen Hashwert der zu signierenden Daten erfolgt, muss dieser Hashwert vom Clientsystem berechnet werden. Als kryptografisches Verfahren kommt hier SHA-256 zum Einsatz. Aus dem obigen Beispiel `eyJpc3MiOiJodHRwczovL2lkcC56ZW50cmFsLmlkcC5...` ergibt sich folgender Hashwert: `dd775a30757431a62bbe12301898511f5d9d5145a58dbd5d6cbae2481b36993f`

[[anchor-read-aut]]
=== Request zum Auslesen des Zertifikats der SMC-B über Konnektor (read_certificate)
Der Konnektor authentifiziert Nutzer anhand einer kartengebundenen, kryptografischen Identität. Die Karte hält den privaten Schlüssel zu dieser Identität, welcher für die Signatur über eine Challenge des IDP genutzt wird. Zur Prüfung der Signatur benötigt der IDP das Zertifikat dieser Identität. Dieses enthält den öffentlichen Schlüssel für die kryptografische Signaturprüfung sowie weitere Nutzerinformationen (Name, KVNR/Telematik-ID, fachliche Rolle), die der IDP in Identitätsbestätigungen zur Nutzung gegenüber dem E-Rezept-Fachdienst attestiert. Der Abruf des Zertifikats erfolgt über die Konnektor-Operation `ReadCertificate`.

[cols="h,a"] 
|===
|URI        |https://192.168.x.y/Konnektorservice
|Method     |POST
|HTTP Header |
----
Content-Type: text/xml; charset=UTF-8
Content-Length: 1234
SOAPAction: "http://ws.gematik.de/conn/CertificateService/v7.4#ReadCardCertificate"
----
|Payload    |
[source,xml]
----
<S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
	<S:Body>
		<ns8:ReadCardCertificate xmlns:ns2="http://ws.gematik.de/conn/CertificateServiceCommon/v2.0" xmlns:ns3="urn:oasis:names:tc:dss:1.0:core:schema" xmlns:ns4="http://www.w3.org/2000/09/xmldsig#" xmlns:ns5="http://ws.gematik.de/conn/ConnectorCommon/v5.0" xmlns:ns6="http://ws.gematik.de/tel/error/v2.0" xmlns:ns7="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:ns8="http://ws.gematik.de/conn/CertificateService/v7.4" xmlns:ns9="http://ws.gematik.de/conn/ConnectorContext/v2.0">
			<ns5:CardHandle>smc-b_2</ns5:CardHandle>
			<ns9:Context>
				<ns5:MandantId>Mandant1</ns5:MandantId>
				<ns5:ClientSystemId>myPVS</ns5:ClientSystemId>
				<ns5:WorkplaceId>WP1</ns5:WorkplaceId>
			</ns9:Context>
			<ns8:CertRefList>
				<ns8:CertRef>C.AUT</ns8:CertRef> <1>
			</ns8:CertRefList>
		</ns8:ReadCardCertificate>
	</S:Body>
</S:Envelope>
----
<1> Hier wird angegeben, dass das Zertifikat zur Authentisierung gegenüber dem IDP aus der SMC-B ausgelesen werden soll.
|===

*Response*
[source,xml]
----
HTTP/1.1 200 OK 
Content-Type: text/xml;charset=utf-8 

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
	<soap:Body>
		<ns3:ReadCardCertificateResponse xmlns="http://ws.gematik.de/conn/ConnectorCommon/v5.0" xmlns:ns2="http://ws.gematik.de/conn/ConnectorContext/v2.0" xmlns:ns3="http://ws.gematik.de/conn/CertificateService/v7.4" xmlns:ns4="http://ws.gematik.de/tel/error/v2.0" xmlns:ns5="http://ws.gematik.de/conn/CertificateServiceCommon/v2.0" xmlns:ns6="http://www.w3.org/2000/09/xmldsig#" xmlns:ns7="urn:oasis:names:tc:dss:1.0:core:schema" xmlns:ns8="urn:oasis:names:tc:SAML:1.0:assertion">
			<Status>
				<Result>OK</Result>
			</Status>
			<ns5:X509DataInfoList>
				<ns5:X509DataInfo>
					<ns5:X509Data>
						<ns5:X509Certificate>MIIFcTCCBFmgAwIBAgIHAXumDkbX3zANBgkqhkiG9w0BAQsFADCBmjELMAkGA1UEBhMCREUxHzAdBgNVBAoMFmdlbWF0aWsgR21iSCBOT1QtVkFMSUQxSDBGBgNVBAsMP0luc3RpdHV0aW9uIGRlcyBHZXN1bmRoZWl0c3dlc2Vucy1DQSBkZXIgVGVsZW1hdGlraW5mcmFzdHJ1a3R1cjEgMB4GA1UEAwwXR0VNLlNNQ0ItQ0EyNCBURVNULU9OTFkwHhcNMjAwNjEwMDAwMDAwWhcNMjUwNjA5MjM1OTU5WjCB+DELMAkGA1UEBhMCREUxFDASBgNVBAcMC03DvGhsaGF1c2VuMQ4wDAYDVQQRDAU5OTk3NDEeMBwGA1UECQwVTGFuZ2Vuc2FsemFlciBTdHIuIDI1MSowKAYDVQQKDCEzLVNNQy1CLVRlc3RrYXJ0ZS04ODMxMTAwMDAxMjkwNjgxHTAbBgNVBAUTFDgwMjc2ODgzMTEwMDAwMTI5MDY4MRQwEgYDVQQEDAtCbGFua2VuYmVyZzEWMBQGA1UEKgwNRG9taW5pay1QZXRlcjEqMCgGA1UEAwwhQXBvdGhla2UgYW0gU3BvcnR6ZW50cnVtVEVTVC1PTkxZMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjVMEf2TTXlfkuCDyiMpo96jA5XRvkaHTy+4qTcDR1awUP4yemfKsB1BTWMMSDrA1/2YdnlZJeynEnQi0K4LWMvTcq+CRGi4ghcIokb2TURZXZ1K6FTJHqITojp9ZRaNTap+kIpOZCmSRa7ftRzEgooPjG6C+7XxUViczlVE17UJMPavWQfY2+A1M/0vx9Jbi7wPmXCMuEvj7yEAVRCGQExVxzbLZPE7FS/vlXcwkFtmnMUVWiQFFXlVLG7uUc9CQFvTXPT5ppDhxAmVeUBLNXKruDkpSeuq3sCi93ln9hXXw/xPeNAAehtvxFp6eMGf5LEVGvZj8v51qu4eDPaKtJwIDAQABo4IBWjCCAVYwEwYDVR0lBAwwCgYIKwYBBQUHAwIwDgYDVR0PAQH/BAQDAgWgMB0GA1UdDgQWBBSEkJ1lgmhiHfVZyKKyVw2Qd86PPDA4BggrBgEFBQcBAQQsMCowKAYIKwYBBQUHMAGGHGh0dHA6Ly9laGNhLmdlbWF0aWsuZGUvb2NzcC8wDAYDVR0TAQH/BAIwADAgBgNVHSAEGTAXMAoGCCqCFABMBIEjMAkGByqCFABMBE0wHwYDVR0jBBgwFoAUeunhb+oUWRYF7gPp0/0hq97p2Z4wgYQGBSskCAMDBHsweaQoMCYxCzAJBgNVBAYTAkRFMRcwFQYDVQQKDA5nZW1hdGlrIEJlcmxpbjBNMEswSTBHMBcMFcOWZmZlbnRsaWNoZSBBcG90aGVrZTAJBgcqghQATAQ2EyEzLVNNQy1CLVRlc3RrYXJ0ZS04ODMxMTAwMDAxMjkwNjgwDQYJKoZIhvcNAQELBQADggEBAGwmbkXMdRrIZwTzUVsdH6RUB7cc3+CcDN0NqLSOM7sdCQrr5NfzcK2dzhc77KVzviZbvz6MxfEq47Y/dPMmtVlU0Amw5bbnYT4WnadjrLOHnKCxLFssrfo0izB7IJvBswMQl/KnUXbk/X57KcNKTYOfuCVVVt+yET63N4qp9YOPiMdCHxu+BUvgwmOgr/enRnh+HgCYVQtzLmDXimBcneRoZg3XgukoMQPd5TlVlZAF1JZ6W8uGN+LEiddnHdzYFVInest3xMzwHj4T3lXLCkr6oc9jvwKe2A2qsBvcbEFDR0mi0CW9NjfJ05v/52GKZZZyjEnFjnHJ1J5r1DlD5S8=
            </ns5:X509Certificate> <1>
					</ns5:X509Data>
				</ns5:X509DataInfo>
			</ns5:X509DataInfoList>
		</ns3:ReadCardCertificateResponse>
	</soap:Body>
</soap:Envelope>
----
<1> Der Konnektor liefert das Zertifikat zurück, wie es auf der Karte gespeichert ist, ASN.1 DER codiert in Base64-Darstellung.

[cols="a,a"] 
|===
|Code   |Type Success  
|200  | OK +
[small]#Die Anfrage wurde erfolgreich bearbeitet.#
|Code   |Type Error   
|400  | Bad Request  +
[small]#Die Anfrage-Nachricht war fehlerhaft aufgebaut.#
|===

[[anchor-sign-challenge]]
=== Signatur mit SMC-B erzeugen (external_authenticate)
Das vom IDP bereitgestellte Challenge-Token muss mit der AUT-Identität der SMC-B signiert werden. Das Primärsystem berechnet den Hashwert der Challenge im vom IDP vorgegebenen SHA-256-Verfahren und ruft für diesen Hashwert die Konnektor-Operation `ExternalAuthenticate` auf. +
Für das obige Challenge-Beispiel ergibt sich der folgende SHA-256-Wert: `dd775a30757431a62bbe12301898511f5d9d5145a58dbd5d6cbae2481b36993f`.

[cols="h,a"] 
|===
|URI        |https://192.168.x.y/Konnektorservice
|Method     |POST
|HTTP Header |
----
Content-Type: text/xml; charset=UTF-8
Content-Length: 1234
SOAPAction: "http://ws.gematik.de/conn/SignatureService/v7.4#ExternalAuthenticate"
----
|Payload    |
[source,xml]
----
<soap-env:Envelope xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/">
  <soap-env:Body>
    <ns0:ExternalAuthenticate xmlns:ns0="http://ws.gematik.de/conn/SignatureService/v7.4">
      <ns1:CardHandle xmlns:ns1="http://ws.gematik.de/conn/ConnectorCommon/v5.0">smc-b_2</ns1:CardHandle> <1>
      <ns2:Context xmlns:ns2="http://ws.gematik.de/conn/ConnectorContext/v2.0">
        <ns3:MandantId xmlns:ns3="http://ws.gematik.de/conn/ConnectorCommon/v5.0">Mandant1</ns3:MandantId>
        <ns4:ClientSystemId xmlns:ns4="http://ws.gematik.de/conn/ConnectorCommon/v5.0">myPVS</ns4:ClientSystemId>
        <ns5:WorkplaceId xmlns:ns5="http://ws.gematik.de/conn/ConnectorCommon/v5.0">WP1</ns5:WorkplaceId>
      </ns2:Context>
      <ns0:OptionalInputs>
        <ns6:SignatureType xmlns:ns6="urn:oasis:names:tc:dss:1.0:core:schema">urn:ietf:rfc:3447</ns6:SignatureType>
        <ns0:SignatureSchemes>RSASSA-PKCS1-v1_5</ns0:SignatureSchemes>
      </ns0:OptionalInputs>
      <ns0:BinaryString>
        <ns7:Base64Data xmlns:ns7="urn:oasis:names:tc:dss:1.0:core:schema">dd775a30757431a62bbe12301898511f5d9d5145a58dbd5d6cbae2481b36993f</ns7:Base64Data> <2>
      </ns0:BinaryString>
    </ns0:ExternalAuthenticate>
  </soap-env:Body>
</soap-env:Envelope>
----
<1> Entsprechend der Mandantenkonfiguration wird hier die SMC-B referenziert, welche der IDP authentifizieren soll.
<2> Der zu signierende Hashwert zur Challenge (Base64-Darstellung des Challengetoken, das zuvor vom IDP bezogen wurde).
|===

*Response*
[source,xml]
----
HTTP/1.1 200 OK 
Content-Type: text/xml;charset=utf-8 

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ns4:ExternalAuthenticateResponse xmlns="http://ws.gematik.de/conn/ConnectorCommon/v5.0" xmlns:ns2="http://ws.gematik.de/conn/ConnectorContext/v2.0" xmlns:ns3="urn:oasis:names:tc:dss:1.0:core:schema" xmlns:ns4="http://ws.gematik.de/conn/SignatureService/v7.4" xmlns:ns5="http://www.w3.org/2000/09/xmldsig#" xmlns:ns6="http://ws.gematik.de/tel/error/v2.0" xmlns:ns7="http://uri.etsi.org/01903/v1.3.2#" xmlns:ns8="http://ws.gematik.de/conn/CertificateServiceCommon/v2.0" xmlns:ns9="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:ns10="http://www.w3.org/2001/04/xmlenc#" xmlns:ns11="http://uri.etsi.org/02231/v2#" xmlns:ns12="urn:oasis:names:tc:dss-x:1.0:profiles:verificationreport:schema#" xmlns:ns13="urn:oasis:names:tc:dss-x:1.0:profiles:SignaturePolicy:schema#" xmlns:ns14="urn:oasis:names:tc:SAML:2.0:assertion">
      <Status>
        <Result>OK</Result>
      </Status>
      <ns3:SignatureObject>
        <ns3:Base64Signature Type="urn:ietf:rfc:3447">N9Ut1Jepp-p77Vu2sOca3FqyiqDPYWKd6N4HO82YazWlg61uVwE49eRntsfSdx8HpGNdY9CerkARRCYAYJSqSw</ns3:Base64Signature> <1>
      </ns3:SignatureObject>
    </ns4:ExternalAuthenticateResponse>
  </soap:Body>
</soap:Envelope>
----
<1> Dieses Element enthält die Signatur, die mittels Konnektor und dem privaten Schlüssel der SMC-B erstellt wurde.

[cols="a,a"] 
|===
|Code   |Type Success  
|200  | OK +
[small]#Die Anfrage wurde erfolgreich bearbeitet. Die angeforderte Ressource wurde vor dem Senden der Antwort erstellt.#
|Code   |Type Error   
|400  | Bad Request  +
[small]#Die Anfrage-Nachricht war fehlerhaft aufgebaut.#
|===

NOTE: *Nutzung der Gesundheitskarte* +
Versicherte weisen sich gegenüber der Telematikinfrastruktur mit der Identität der elektronischen Gesundheitskarte aus.
Der Ablauf ist analog zu dem oben ausgeführt Ablauf für Primärsysteme. Das E-Rezept-FdV bündelt dabei (wie das Primärsystem) in Stufe 1 die E-Rezept-Fachlogik und die Funktion des Authenticator-Moduls. Die Signatur der Challenge erfolgt bei Nutzung der elektronischen Gesundheitskarte bspw. über die NFC-Schnittstelle des Mobilgeräts.
Dabei wird das Schlüsselmaterial PRK.CH.AUT für Private-Key und C.CH.AUT für das Zertifikat inkl. PublicKey verwendet.

[[anchor-vau-transport]]
= Verschlüsselter Transportkanal zur Vertrauenswürdigen Ausführungsumgebung ("VAU-Transport")
Der Einsatz moderner Transportverschlüsselung ab TLS 1.2 schützt vor der Einsicht sensibler Daten beim Transport über das Internet. Dabei sind sowohl die Daten des HTTP-Body als auch die aufgerufene URL und die HTTP-Header verschlüsselt. In modernen Cloud-Infrastrukturen enden solche TLS-Verbindungen meist an einem Internetgateway, müssen jedoch in einer Serverinfrastruktur häufig zu dahinterliegenden Applicationservern und -diensten weitertransportiert werden. 

Um sensible Daten bis hinein in einen vertrauenswürdigen Ausführungskontext verschlüsselt zu transportieren, erfolgt der Zugang zum E-Rezept-Fachdienst mit einer zusätzlichen Transportverschlüsselung für eine kryptografische Identität der vertrauenswürdigen Ausführungsumgebung (VAU). Dabei werden die Daten des HTTP-Body für den Verarbeitungskontext der VAU  um einen symmetrischen Antwortschlüssel ergänzt und anschließend asymmetrisch verschlüsselt. Dieser verschlüsselte HTTP-Request wird dann mittels TLS transportverschlüsselt an den E-Rezept-Fachdienst übergeben. 

image:api_vau_transport.png[width=80%]

NOTE: Das Diagramm inkl. der konkreten Ablaufbeschreibung befindet sich auch im Spezifikationsdokument [gemSpec_Krypt] in Kapitel 7.

Die VAU des E-Rezept-Fachdienstes erzeugt eine HTTP-Response entsprechend des Workflows im E-Rezept und verschlüsselt diese Response symmetrisch mit dem vom Client bereitgestellten Antwortschlüssel. Die verschlüsselte Response wird anschließend mittels TLS transportverschlüsselt an den Client zurückgegeben.

Ein zusätzlich in den Aufrufen vom E-Rezept-Fachdienst generiertes, wechselndes Nutzerpseudonym wirkt zusätzlich Überlastungsangriffen entgegen, indem Aufrufe ohne Nutzerpseudonym mit einer geringeren Priorität bearbeitet werden.

NOTE: Im Verzeichnis  link:samples/VAUSimpleExample[VAUSimpleExample] finden Sie eine C#-Beispielimplementierung eines VAU-Clients, der uns freundlicherweise von den Apothekensoftware-Häusern bereitgestellt wurde.

==== Kennzeichnung des verschlüsselten Inhalts für Routing
Der E-Rezept-Fachdienst benötigt eine Kennzeichnung im äußeren http-Request, um den verschlüsselten Inhalt an den fachlich zuständigen VAU-Kontext zu routen. Um eine Überlastung nutzerrollen- und workflowspezifischer VAU-Kontexte zu vermeiden, werden die http-Header `X-erp-user` und `X-erp-resource` genutzt. Die folgende Tabelle zeigt die Belegung der Header zur Nutzung durch die entsprechenden E-Rezept-Nutzer (in den Beispielen der verschiedenen UseCases sind die jeweiligen Header-Belegungen für den äußeren http-Request angegeben):

[cols="a,a"] 
|===
|*Leistungserbringer (PVS, AVS ,KIS)*       |*Versicherte (E-Rezept-App)*
|`X-erp-user: l` +
Dieser Header mit Wert "l" (kleines "L") signalisiert dem E-Rezept-Fachdienst einen Zugriff durch Leistungserbringer
|`X-erp-user: v` +
Dieser Header mit Wert "v" (kleines "V") signalisiert dem E-Rezept-Fachdienst einen Zugriff durch Versicherte
|`X-erp-resource: Task` +
`X-erp-resource: Communication` +
Der Header mit diesem Wert signalisiert den Zugriff auf eine bestimmte FHIR-Ressource, z.B. Task. Es wird immer nur eine Ressource genannt, da Zugriffe auch immer nur an eine Ressource adressiert werden.
Hinweis: Beim Zugriff auf das CapabilityStatement mit GET /metadata wird entsprechend `X-erp-resource: metadata` angegeben. Die Auswertung erfolgt *Case-Sensitiv*
|`X-erp-resource: Task` +
`X-erp-resource: MedicationDispense` +
`X-erp-resource: Communication` +
`X-erp-resource: AuditEvent`
|===

== Verbindungsaufbau zum E-Rezept-Fachdienst
Zunächst muss das Verschlüsselungszertifikat der VAU vom E-Rezept-Fachdienst abgerufen werden. 

[cols="h,a"] 
|===
|URI        |https://prescriptionserver.telematik/VAUCertificate
|Method     |GET
|HTTP Header |X-erp-user: l <1>
|Payload    | -
|Response |
[source,json]
----
<1> Der Header `X-erp-user` signalisiert dem E-Rezept-Fachdienst einen Zugriff aus der Leistungserbringerumgebung [`l` - kleines "L"] (muss in jedem Header angegeben werden).

HTTP/1.1 200 OK
Content-Type: application/pkix-cert 

1100110001111111000000011011000010100111100001111000010010111001...
----
|===

Der E-Rezept-Fachdienst stellt zusätzlich eine frische OCSP-Response für die erweiterte Prüfung des Verschlüsselungszertifikats bereit.

[cols="h,a"] 
|===
|URI        |https://prescriptionserver.telematik/VAUCertificateOCSPResponse
|Method     |GET
|HTTP Header |X-erp-user: l <1>
|Payload    | -
|Response |
[source,json]
----
<1> Der Header `X-erp-user` signalisiert dem E-Rezept-Fachdienst einen Zugriff aus der Leistungserbringerumgebung [`l` - kleines "L"] (muss in jedem Header angegeben werden).

HTTP/1.1 200 OK
Content-Type: application/ocsp-response 

100100100110001011110001110111011000110000101111101100100111011...
----
|===

== Request versenden
Für den verschlüsselten VAU-Transport wird der zu transportierende HTTP-Request für die VAU in mehreren Schritten aufbereitet. Als Beispiel wird im Folgenden die Abfrage aller E-Rezepte eines Versicherten verwendet.
[source,json]
----
GET /Task HTTP/1.1
Host: prescriptionserver.telematik
Authorization: Bearer eyJraWQ.ewogImL2pA10Qql22ddtutrvx4FsDlz.rHQjEmB1lLmpqn9J
User-Agent: E-Rezept FdV 1.0.0
Accept: application/fhir+json;charset=utf-8
----
Zunächst müssen im Client eine zufällige Request-ID (z.B. `b69f01734f34376ddcdbdbe9af18a06f`) und ein symmetrischer Antwortschlüssel (z.B. `16bac90134c635e4ec85fae0e4885d9f`) generiert werden. +
Als nächstes wird die folgende leerzeichengetrennte Zeichenkette `p` für die anschließende Verschlüsselung gebildet: `p="1" + " " + ACCESS_TOKEN + " " + Request-ID + " " + Antwortschlüssel + " " + HTTP-Request`, mit obigem Beispiel ergibt sich für `p`:
[source,json]
----
"1 eyJraWQ.ewogImL2pA10Qql22ddtutrvx4FsDlz.rHQjEmB1lLmpqn9J b69f01734f34376ddcdbdbe9af18a06f 16bac90134c635e4ec85fae0e4885d9f GET /Task HTTP/1.1
Host: prescriptionserver.telematik
Authorization: Bearer eyJraWQ.ewogImL2pA10Qql22ddtutrvx4FsDlz.rHQjEmB1lLmpqn9J
User-Agent: E-Rezept FdV 1.0.0
Accept: application/fhir+json;charset=utf-8"
----
Diese Zeichenkette wird nun mit dem ECIES-Verfahrens [SEC1-2009] und dem öffentlichen Schlüssel aus dem zuvor abgerufenen Verschlüsselungszertifikat der VAU hybrid verschlüsselt. Sei `1101110011011110000101101000111000010101100110111011111100011111111110001101110010011010010110000101000001011000000100` ein unvollständiges Beispiel für das Ergebnis der Verschlüsselungsoperation. Dieses wird nun als Payload im HTTP-Body des folgenden Requests an den E-Rezept-Fachdienst übergeben.

[cols="h,a"] 
|===
|URI        |https://prescriptionserver.telematik/VAU/0
|Method     |POST
|HTTP Header |`Content-Type: application/octet-stream` +
X-erp-user: l <1>
|HTTP Body   |`1101110011011110000101101000111000010101100110111011111100011111111110001101110010011010010110000101000001011000000100`
|Response |
[source,json]
----
<1> Der Header `X-erp-user` signalisiert dem E-Rezept-Fachdienst einen Zugriff aus der Leistungserbringerumgebung [`l` - kleines "L"] (muss in jedem Header angegeben werden).

HTTP/1.1 200 OK
Content-Type: application/octet-stream
Userpseudonym: 270810c79748768a9b0aefbf52c8d72be7ad5e0d2d328d9bb70dbf58623fc7ae

001111101111100110001001001111010110010010111110101100100011110...
----
|===
NOTE: Die `0` am Ende der URL des Requests steht für ein (dem Client nicht bekanntes) Nutzerpseudonym, nach der ersten Antwort der VAU des E-Rezept-Fachdienstes kann das vom Fachdienst mitgeteilte `Userpseudonym` `270810c79748768a9b0aefbf52c8d72be7ad5e0d2d328d9bb70dbf58623fc7ae` anstelle der `0` verwendet werden, um Folgezugriffe höher zu priorisieren.


== Response verarbeiten
Nach dem erfolgreichen Abschluss der Bearbeitung des Requests durch die VAU des E-Rezept-Fachdienstes erhält der Client die verschlüsselte HTTP-Response der VAU in einer äußeren "VAU-Transport"-HTTP-Response.
Der HTTP-Statuscode 200 signalisiert dabei die korrekte Verarbeitung und Erstellung der verschlüsselten Antwort. Die innere HTTP-Response des fachlichen Ergebnisses aus der VAU kann dabei einen abweichenden HTTP-Statuscode beinhalten, wenn aufgrund der Daten oder Verarbeitung innerhalb der VAU Fehlerzustände eintreten oder ungültige Daten übergeben wurden. Sei `001111101111100110001001001111010110010010111110101100100011110...` die verschlüsselte Response zum obigen Beispiel. Die Entschlüsselung mit dem für den Request generierten Antwortschlüssel `16bac90134c635e4ec85fae0e4885d9f`mittels AES-GCM liefert die innere HTTP-Response der VAU als leerzeichengetrennte Zeichenkette:
[source,json]
----
1 b69f01734f34376ddcdbdbe9af18a06f HTTP/1.1 200 OK
Content-Type: application/fhir+json;charset=utf-8
Content-Location: https://prescriptionserver.telematik/Bundle/f5ba6eaf-9052-42f6-ac4e-fadceed7293b

{
  "resourceType": "Bundle",
  "id": "f5ba6eaf-9052-42f6-ac4e-fadceed7293b",
  "meta": {
    "lastUpdated": "2020-03-01T07:02:37.836+00:00"
  },
  "type": "searchset",
  "total": 2,
  "link": [{
    "relation": "self",
    "url": "https://prescriptionserver.telematik/Task/"
  }],
  "entry": [{
    "fullUrl": "https://prescriptionserver.telematik/Task/588780",    
    "resource": {
      "resourceType": "Task",
      "id":"588780",
      "meta": {
        "profile":  [
            "https://gematik.de/fhir/StructureDefinition/ErxTask"
        ]
      },
      "extension":  [{
        "url": "https://gematik.de/fhir/StructureDefinition/PrescriptionType",
        "valueCoding": {
          "system": "https://gematik.de/fhir/CodeSystem/Flowtype",
          "code": "160",
          "display": "Muster 16 (Apothekenpflichtige Arzneimittel)"
        }
      }, {
        "url": "https://gematik.de/fhir/StructureDefinition/AcceptDate",
        "valueDateTime": "2020-03-02T08:25:05+00:00"
      }, {
        "url": "https://gematik.de/fhir/StructureDefinition/ExpiryDate",
        "valueDateTime": "2020-05-02T08:25:05+00:00"
      }],
      "identifier":  [{
        "system": "https://gematik.de/fhir/NamingSystem/PrescriptionID",
        "value": "160.123.456.789.123.58"
      }, {
        "system": "https://gematik.de/fhir/NamingSystem/AccessCode",
        "value": "777bea0e13cc9c42ceec14aec3ddee2263325dc2c6c699db115f58fe423607ea"
      }, {
        "system": "https://gematik.de/fhir/NamingSystem/Secret",
        "value": "c36ca26502892b371d252c99b496e31505ff449aca9bc69e231c58148f6233cf"
      }],
      "status": "in-progress",
      "intent": "order",
      "for": {
        "identifier": {
          "system": "http://fhir.de/NamingSystem/gkv/kvid-10",
          "value": "X123456789"
        }
      },
      "authoredOn": "2020-03-02T08:25:05+00:00",
      "lastModified": "2020-03-02T08:45:05+00:00",
      "performerType":  [{
        "coding":  [{
          "system": "urn:ietf:rfc:3986",
          "code": "urn:oid:1.2.276.0.76.4.54",
          "display": "Öffentliche Apotheke"
        }]
      }],
      "input":  [{
        "type": {
          "coding":  [{
            "system": "https://gematik.de/fhir/CodeSystem/Documenttype",
            "code": "1",
            "display": "Health Care Provider Prescription"
          }]
        },
        "valueReference": {
          "reference": "Bundle/KbvPrescriptionExample"
        }
      }]
    },
    "search": {
      "mode": "match"
    }
  }]
}
----

NOTE: Die innere HTTP-Response hat die folgende Struktur "1" + " " + ursprüngliche-Request-ID + " " + Response-Header-und-Body

WARNING: Ein Splitten der inneren Struktur anhand des Leerzeichens " " könnte dazu führen, dass auch der Payload im inneren HTTP-Response-Body zerstückelt wird. Robuster ist das Prüfen auf Vorhandensein der ursprünglichen Request-ID und anschließendes Entfernen des von der VAU hinzugefügten Präfixes `"1" + " " + ursprüngliche-Request-ID + " "`. Nun kann die innere HTTP-Response standardgemäß weiterverarbeitet werden.


