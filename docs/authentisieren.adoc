:imagesdir: ../images
:caution-caption: Achtung
:important-caption: Wichtig
:note-caption: Hinweis
:tip-caption: Tip
:warning-caption: Warnung
ifdef::env-github[]
:imagesdir: https://github.com/gematik/api-erp/raw/master/images
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc: macro
:toclevels: 3
:toc-title: Inhaltsverzeichnis
image:gematik_logo.jpg[width=35%] 

= E-Rezept API-Dokumentation
Hier dokumentiert die gematik die Nutzung der Schnittstellen, um sich mit der Telematikinfrastruktur zu verbinden. Das betrifft zum einen die Authentifizierung als Nutzer oder Institution durch den Identity Provider (IDP) und zum anderen den verschlüsselten Datentransport auf Anwendungsebene ("VAU-Transport").

toc::[]

= Als Nutzer der Telematikinfrastruktur authentifiziert werden
Die Telematikinfrastruktur gestattet keinen Zugriff auf Dienste ohne eine Identifikation der Nutzer. Dies dient der Durchsetzung von Zugriffsregeln und der Protokollierung des Zugriffs auf medizinische Daten von Versicherten. Mit der Authentifizierung der Nutzer erfolgt keine Profilbildung, Sessiondaten werden temporär verwaltet und nach Beendigung einer Sesssion unverzüglich gelöscht. Die Protokollierung von Zugriffen auf medizinische Daten erfolgt in Abhängigkeit der genutzten Schnittstellen in den jeweils aufgerufenen Services sowie in Abhängigkeit der fachlichen Anforderungen gemäß gematik-Spezifikationen. + 

Die Authentifizierung übernimmt mit der Einführung des E-Rezepts ein zentraler Identity Provider (IDP). Der IDP erkennt Nutzer anhand ihrer kartenbasierten Identitäten und stellt die Identitätsmerkmale (Name, KVNR bzw. Telematik-ID) der Zertifikate auf der Karte in ID_TOKEN und ACCESS_TOKEN für die Nutzung im E-Rezept-Fachdienst bereit.

== Ablauf des Authentifizierungsprotokolls
Leistungserbringerinstitutionen (Praxen, Apotheken, Krankenhäuser) weisen sich gegenüber der Telematikinfrastruktur mit der Identität des Praxisausweises SMC-B aus. Die Authentifizierung erfolgt gegenüber dem Identity Provider (IDP) unter Nutzung der Konnektorschnittstelle.

Das Primärsystem adressiert Anfragen an den IDP über eine bekannt zu machende Adresse *z.B.* `idp.ti-dienste.de`, dabei veröffentlicht der IDP sein DiscoverDocument mit den Informationen zu verschiedenen Endpunkten zur Tokenausstellung unter einer "/.well-known"-Adresse, d.h. `idp.ti-dienste.de/.well-known/openid-configuration`.

Die folgende Abbildung zeigt den detaillierten Ablauf mit allen beteiligten Komponenten. Das Primärsystem gliedert sich in die E-Rezept-Fachlogik und ein Authenticator-Modul. Letzteres übernimmt die Authentisierung mittels der kartenbasierten Identität unter Nutzung der Konnektorschnittstellen. Der IDP authentifiziert den Nutzer anhand der kartenbasierten Identität und einer Signatur durch das Schlüsselmaterial auf der Karte (SMC-B) und stellt bei Erfolg während der Dauer einer Nutzersession (ID_TOKEN-Gültigkeitsdauer) Zugriffstoken (ACCESS_TOKEN) für den Zugriff auf den Fachdienst aus. 

image:token_verschluesselung_ps.png[width=100%] 

NOTE: Die Datei link:../images/PS-IDP-Flow.png[PS-IDP-Flow.png^] im Anhang gibt ein konkretes Beispiel mit Request- und Response-Parametern für die Authentifizierung mittels SMC-B einer Test-Apotheke "3-SMC-B-Testkarte-883110000xxxxxx" (siehe auch "professionOID": "1.2.276.0.76.4.54" = "Öffentliche Apotheke").

Im Folgenden werden die einzelnen Schritte erläutert.

[cols="a,a,a"] 
[cols="1%,1%,100%"]
|===
|*Step*|*eRp (Fachlogik) / AM (Auth-Modul)*|*Beschreibung*
|1|eRp|Laden der Zertifikatsliste vom FD  [https://erp.zentral.erp.splitdns.ti-dienste.de/CertList] Das root-Zertifikat zu diesen Zertifikaten befindet sich als Vertrauensanker in der App und wird im Build-Prozess eingebracht.  Siehe gemSpec_Krypt#7.2
|2|eRp|Erzeugen eine code_verifiers (128 zufällige Zeichen aus der Menge [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~")
|3|eRp|Erzeugen code_challenge: sha256(code_verifier)
|4|eRp|Aufruf AM mit code_challenge und Zertifikatsliste
|5|AM|Laden des Discovery Documents (DD) vom IDP
 [https://idp.zentral.idp.splitdns.ti-dienste.de/.well-known/openid-configuration] +
*Schritt 1 im Rbel-Flow*
|6|AM|Lesen des DD-Signatur-Zertifikats und IDP-Verschlüsselungszertifikats von PUK_URI_DISC +
*Schritt 3 + 5 im Rbel-Flow*
|7|AM|Prüfung der Signatur des DD gegen das Zertifikat
|8|AM|Prüfung des Zertifikats im DD gegen die Zertifikatsliste aus Step 1
|9|AM|Lesen der jwks_uri im DD und Laden des jwks von dieser URL
|10|AM|Lesen von authorization_endpoint und token_endpoint aus DD
|11|AM|Ermittlung von PuK_AUTH_SIG, PuK_AUTH_ENC, PuK_TOKEN_SIG, PuK_TOKEN_ENC aus jwks
|12|AM|Senden der code_challenge (als URL-Parameter 'code_challenge') an authorization_endpoint des IDP, IDP antwortet mit challenge und user_consent +
*Schritt 7 im Rbel-Flow*
|13|AM|Anzeige user_consent vom IDP
|14|AM|Berechnen des HASH-Werts der empfangenen Challenge
|15|AM|SMC-B-Kommunikation zum +
1. Lesen des Zertifikats C.HCI.AUT der SMC-B über Konnektor - <<Request zum Auslesen des Zertifikats der SMC-B über Konnektor (read_certificate),Details siehe unten>> +
2. Signieren des Challenge-HASH mit PRK.HCI.AUT der SMC-B über Konnektor - <<Signatur mit SMC-B erzeugen (external_authenticate),Details siehe unten>> +
|16|AM|jwe-Verschlüsselung der signierten Challenge als njwt und des Zertifikats
 Verschlüsselung mit PuK_AUTH_ENC aus jwks
|17|AM|Senden der verschlüsselten Challenge und des verschlüsselten Zertifikats an IDP, IDP antwortet mit AUTHORIZATION_CODE (AC) und SSO_TOKEN +
*Schritt 9 im Rbel-Flow*
|18|AM|Speicherung SSO_TOKEN
|19|AM|Rückgabe AC an App, zusammen mit 
 PuK_TOKEN_SIG, PuK_TOKEN_ENC aus jwks,
 token_endpoint-URL
|20|eRp|Generierung eine Token-Keys (AES256)
|21|eRp|Erstellung des key-verifiers (JSON-Objekts mit Token-Key und code_verifiers)
|22|eRp|jwe-Verschlüsslung des key-verifiers mit PuK_TOKEN_ENC aus jwks
|23|eRp|Senden des verschlüsselten key-verifiers und des AC an token_endpoint des IDP
 IDP antwortet mit jwe-verschlüsseltem ACCESS_TOKEN +
*Schritt 11 im Rbel-Flow*
|24|eRp|Jwe-Entschlüsselung ACCESS_TOKEN mit Hilfe des Token-Keys
|25|eRp|Prüfung der Signatur des ACCESS_TOKENs gegen PuK_TOKEN_SIG
|===





=== Vorbereitende Schritte für die Authentifizierung mittels der SMC-B
1. Dem Nutzer soll der vom IDP bereitgestellte UserConsent angezeigt werden. Stimmt der Nutzer der Bereitstellung der Daten für den E-Rezept-Fachdienst nicht zu, muss der Authentifizierungsvorgang abgebrochen werden, da der Fachdienst ohne diese Informationen den E-Rezept-Workflow nicht umsetzen kann.
2. Die vom IDP in der obigen Response übermittelte Challenge beinhaltet ein Challenge-Token `{"iss":"https://idp.zentral.idp.splitdns.ti-dienste.de","response_type":"code","snc":"syQAvJmxPnRtLjT6uPVERb_RF7MmVzhS1sP8FbHjhLM","code_challenge_method":"S256","token_type":"challenge","nonce":"887766","client_id":"gematikTestPs","scope":"openid e-rezept","state":"xxxstatexxx","redirect_uri":"http://test-ps.gematik.de/erezept","exp":1616686048,"iat":1616685868,"code_challenge":"Ca3Ve8jSsBQOBFVqQvLs1E-dGV1BXg2FTvrd-Tg19Vg","jti":"5e5ad23ae3e7d8aa"}` in Base64-Codierung `eyJpc3MiOiJodHRwczovL2lkcC56ZW50cmFsLmlkcC5zcGxpdGRucy50aS1kaWVuc3RlLmRlIiwicmVzcG9uc2VfdHlwZSI6ImNvZGUiLCJzbmMiOiJzeVFBdkpteFBuUnRMalQ2dVBWRVJiX1JGN01tVnpoUzFzUDhGYkhqaExNIiwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kIjoiUzI1NiIsInRva2VuX3R5cGUiOiJjaGFsbGVuZ2UiLCJub25jZSI6Ijg4Nzc2NiIsImNsaWVudF9pZCI6ImdlbWF0aWtUZXN0UHMiLCJzY29wZSI6Im9wZW5pZCBlLXJlemVwdCIsInN0YXRlIjoieHh4c3RhdGV4eHgiLCJyZWRpcmVjdF91cmkiOiJodHRwOi8vdGVzdC1wcy5nZW1hdGlrLmRlL2VyZXplcHQiLCJleHAiOjE2MTY2ODYwNDgsImlhdCI6MTYxNjY4NTg2OCwiY29kZV9jaGFsbGVuZ2UiOiJDYTNWZThqU3NCUU9CRlZxUXZMczFFLWRHVjFCWGcyRlR2cmQtVGcxOVZnIiwianRpIjoiNWU1YWQyM2FlM2U3ZDhhYSJ9`. Da die Signatur immer über einen Hashwert der zu signierenden Daten erfolgt, muss dieser Hashwert vom Clientsystem berechnet werden. Als kryptografisches Verfahren kommt hier SHA-256 zum Einsatz. Aus dem obigen Beispiel `eyJpc3MiOiJodHRwczovL2lkcC56ZW50cmFsLmlkcC5...` ergibt sich folgender Hashwert: `dd775a30757431a62bbe12301898511f5d9d5145a58dbd5d6cbae2481b36993f`


=== Request zum Auslesen des Zertifikats der SMC-B über Konnektor (read_certificate)
Der Konnektor authentifiziert Nutzer anhand einer kartengebundenen, kryptografischen Identität. Die Karte hält den privaten Schlüssel zu dieser Identität, welcher für die Signatur über eine Challenge des IDP genutzt wird. Zur Prüfung der Signatur benötigt der IDP das Zertifikat dieser Identität. Dieses enthält den öffentlichen Schlüssel für die kryptografische Signaturprüfung sowie weitere Nutzerinformationen (Name, KVNR/Telematik-ID, fachliche Rolle), die der IDP in Identitätsbestätigungen zur Nutzung gegenüber dem E-Rezept-Fachdienst attestiert. Der Abruf des Zertifikats erfolgt über die Konnektor-Operation `ReadCertificate`.

[cols="h,a"] 
|===
|URI        |https://192.168.x.y/Konnektorservice
|Method     |POST
|HTTP Header |
----
Content-Type: text/xml; charset=UTF-8
Content-Length: 1234
SOAPAction: "http://ws.gematik.de/conn/CertificateService/v7.4#ReadCardCertificate"
----
|Payload    |
[source,xml]
----
<S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
	<S:Body>
		<ns8:ReadCardCertificate xmlns:ns2="http://ws.gematik.de/conn/CertificateServiceCommon/v2.0" xmlns:ns3="urn:oasis:names:tc:dss:1.0:core:schema" xmlns:ns4="http://www.w3.org/2000/09/xmldsig#" xmlns:ns5="http://ws.gematik.de/conn/ConnectorCommon/v5.0" xmlns:ns6="http://ws.gematik.de/tel/error/v2.0" xmlns:ns7="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:ns8="http://ws.gematik.de/conn/CertificateService/v7.4" xmlns:ns9="http://ws.gematik.de/conn/ConnectorContext/v2.0">
			<ns5:CardHandle>smc-b_2</ns5:CardHandle>
			<ns9:Context>
				<ns5:MandantId>Mandant1</ns5:MandantId>
				<ns5:ClientSystemId>myPVS</ns5:ClientSystemId>
				<ns5:WorkplaceId>WP1</ns5:WorkplaceId>
			</ns9:Context>
			<ns8:CertRefList>
				<ns8:CertRef>C.AUT</ns8:CertRef> <1>
			</ns8:CertRefList>
		</ns8:ReadCardCertificate>
	</S:Body>
</S:Envelope>
----
<1> Hier wird angegeben, dass das Zertifikat zur Authentisierung gegenüber dem IDP aus der SMC-B ausgelesen werden soll.
|===

*Response*
[source,xml]
----
HTTP/1.1 200 OK 
Content-Type: text/xml;charset=utf-8 

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
	<soap:Body>
		<ns3:ReadCardCertificateResponse xmlns="http://ws.gematik.de/conn/ConnectorCommon/v5.0" xmlns:ns2="http://ws.gematik.de/conn/ConnectorContext/v2.0" xmlns:ns3="http://ws.gematik.de/conn/CertificateService/v7.4" xmlns:ns4="http://ws.gematik.de/tel/error/v2.0" xmlns:ns5="http://ws.gematik.de/conn/CertificateServiceCommon/v2.0" xmlns:ns6="http://www.w3.org/2000/09/xmldsig#" xmlns:ns7="urn:oasis:names:tc:dss:1.0:core:schema" xmlns:ns8="urn:oasis:names:tc:SAML:1.0:assertion">
			<Status>
				<Result>OK</Result>
			</Status>
			<ns5:X509DataInfoList>
				<ns5:X509DataInfo>
					<ns5:X509Data>
						<ns5:X509Certificate>MIIFcTCCBFmgAwIBAgIHAXumDkbX3zANBgkqhkiG9w0BAQsFADCBmjELMAkGA1UEBhMCREUxHzAdBgNVBAoMFmdlbWF0aWsgR21iSCBOT1QtVkFMSUQxSDBGBgNVBAsMP0luc3RpdHV0aW9uIGRlcyBHZXN1bmRoZWl0c3dlc2Vucy1DQSBkZXIgVGVsZW1hdGlraW5mcmFzdHJ1a3R1cjEgMB4GA1UEAwwXR0VNLlNNQ0ItQ0EyNCBURVNULU9OTFkwHhcNMjAwNjEwMDAwMDAwWhcNMjUwNjA5MjM1OTU5WjCB+DELMAkGA1UEBhMCREUxFDASBgNVBAcMC03DvGhsaGF1c2VuMQ4wDAYDVQQRDAU5OTk3NDEeMBwGA1UECQwVTGFuZ2Vuc2FsemFlciBTdHIuIDI1MSowKAYDVQQKDCEzLVNNQy1CLVRlc3RrYXJ0ZS04ODMxMTAwMDAxMjkwNjgxHTAbBgNVBAUTFDgwMjc2ODgzMTEwMDAwMTI5MDY4MRQwEgYDVQQEDAtCbGFua2VuYmVyZzEWMBQGA1UEKgwNRG9taW5pay1QZXRlcjEqMCgGA1UEAwwhQXBvdGhla2UgYW0gU3BvcnR6ZW50cnVtVEVTVC1PTkxZMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjVMEf2TTXlfkuCDyiMpo96jA5XRvkaHTy+4qTcDR1awUP4yemfKsB1BTWMMSDrA1/2YdnlZJeynEnQi0K4LWMvTcq+CRGi4ghcIokb2TURZXZ1K6FTJHqITojp9ZRaNTap+kIpOZCmSRa7ftRzEgooPjG6C+7XxUViczlVE17UJMPavWQfY2+A1M/0vx9Jbi7wPmXCMuEvj7yEAVRCGQExVxzbLZPE7FS/vlXcwkFtmnMUVWiQFFXlVLG7uUc9CQFvTXPT5ppDhxAmVeUBLNXKruDkpSeuq3sCi93ln9hXXw/xPeNAAehtvxFp6eMGf5LEVGvZj8v51qu4eDPaKtJwIDAQABo4IBWjCCAVYwEwYDVR0lBAwwCgYIKwYBBQUHAwIwDgYDVR0PAQH/BAQDAgWgMB0GA1UdDgQWBBSEkJ1lgmhiHfVZyKKyVw2Qd86PPDA4BggrBgEFBQcBAQQsMCowKAYIKwYBBQUHMAGGHGh0dHA6Ly9laGNhLmdlbWF0aWsuZGUvb2NzcC8wDAYDVR0TAQH/BAIwADAgBgNVHSAEGTAXMAoGCCqCFABMBIEjMAkGByqCFABMBE0wHwYDVR0jBBgwFoAUeunhb+oUWRYF7gPp0/0hq97p2Z4wgYQGBSskCAMDBHsweaQoMCYxCzAJBgNVBAYTAkRFMRcwFQYDVQQKDA5nZW1hdGlrIEJlcmxpbjBNMEswSTBHMBcMFcOWZmZlbnRsaWNoZSBBcG90aGVrZTAJBgcqghQATAQ2EyEzLVNNQy1CLVRlc3RrYXJ0ZS04ODMxMTAwMDAxMjkwNjgwDQYJKoZIhvcNAQELBQADggEBAGwmbkXMdRrIZwTzUVsdH6RUB7cc3+CcDN0NqLSOM7sdCQrr5NfzcK2dzhc77KVzviZbvz6MxfEq47Y/dPMmtVlU0Amw5bbnYT4WnadjrLOHnKCxLFssrfo0izB7IJvBswMQl/KnUXbk/X57KcNKTYOfuCVVVt+yET63N4qp9YOPiMdCHxu+BUvgwmOgr/enRnh+HgCYVQtzLmDXimBcneRoZg3XgukoMQPd5TlVlZAF1JZ6W8uGN+LEiddnHdzYFVInest3xMzwHj4T3lXLCkr6oc9jvwKe2A2qsBvcbEFDR0mi0CW9NjfJ05v/52GKZZZyjEnFjnHJ1J5r1DlD5S8=
            </ns5:X509Certificate> <1>
					</ns5:X509Data>
				</ns5:X509DataInfo>
			</ns5:X509DataInfoList>
		</ns3:ReadCardCertificateResponse>
	</soap:Body>
</soap:Envelope>
----
<1> Der Konnektor liefert das Zertifikat zurück, wie es auf der Karte gespeichert ist, ASN.1 DER codiert in Base64-Darstellung.

[cols="a,a"] 
|===
|Code   |Type Success  
|200  | OK +
[small]#Die Anfrage wurde erfolgreich bearbeitet.#
|Code   |Type Error   
|400  | Bad Request  +
[small]#Die Anfrage-Nachricht war fehlerhaft aufgebaut.#
|===


=== Signatur mit SMC-B erzeugen (external_authenticate)
Das vom IDP bereitgestellte Challenge-Token muss mit der AUT-Identität der SMC-B signiert werden. Das Primärsystem berechnet den Hashwert der Challenge im vom IDP vorgegebenen SHA-256-Verfahren und ruft für diesen Hashwert die Konnektor-Operation `ExternalAuthenticate` auf. +
Für das obige Challenge-Beispiel ergibt sich der folgende SHA-256-Wert: `dd775a30757431a62bbe12301898511f5d9d5145a58dbd5d6cbae2481b36993f`.

[cols="h,a"] 
|===
|URI        |https://192.168.x.y/Konnektorservice
|Method     |POST
|HTTP Header |
----
Content-Type: text/xml; charset=UTF-8
Content-Length: 1234
SOAPAction: "http://ws.gematik.de/conn/SignatureService/v7.4#ExternalAuthenticate"
----
|Payload    |
[source,xml]
----
<soap-env:Envelope xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/">
  <soap-env:Body>
    <ns0:ExternalAuthenticate xmlns:ns0="http://ws.gematik.de/conn/SignatureService/v7.4">
      <ns1:CardHandle xmlns:ns1="http://ws.gematik.de/conn/ConnectorCommon/v5.0">smc-b_2</ns1:CardHandle> <1>
      <ns2:Context xmlns:ns2="http://ws.gematik.de/conn/ConnectorContext/v2.0">
        <ns3:MandantId xmlns:ns3="http://ws.gematik.de/conn/ConnectorCommon/v5.0">Mandant1</ns3:MandantId>
        <ns4:ClientSystemId xmlns:ns4="http://ws.gematik.de/conn/ConnectorCommon/v5.0">myPVS</ns4:ClientSystemId>
        <ns5:WorkplaceId xmlns:ns5="http://ws.gematik.de/conn/ConnectorCommon/v5.0">WP1</ns5:WorkplaceId>
      </ns2:Context>
      <ns0:OptionalInputs>
        <ns6:SignatureType xmlns:ns6="urn:oasis:names:tc:dss:1.0:core:schema">urn:ietf:rfc:3447</ns6:SignatureType>
        <ns0:SignatureSchemes>RSASSA-PKCS1-v1_5</ns0:SignatureSchemes>
      </ns0:OptionalInputs>
      <ns0:BinaryString>
        <ns7:Base64Data xmlns:ns7="urn:oasis:names:tc:dss:1.0:core:schema">dd775a30757431a62bbe12301898511f5d9d5145a58dbd5d6cbae2481b36993f</ns7:Base64Data> <2>
      </ns0:BinaryString>
    </ns0:ExternalAuthenticate>
  </soap-env:Body>
</soap-env:Envelope>
----
<1> Entsprechend der Mandantenkonfiguration wird hier die SMC-B referenziert, welche der IDP authentifizieren soll.
<2> Der zu signierende Hashwert zur Challenge (Base64-Darstellung des Challengetoken, das zuvor vom IDP bezogen wurde).
|===

*Response*
[source,xml]
----
HTTP/1.1 200 OK 
Content-Type: text/xml;charset=utf-8 

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ns4:ExternalAuthenticateResponse xmlns="http://ws.gematik.de/conn/ConnectorCommon/v5.0" xmlns:ns2="http://ws.gematik.de/conn/ConnectorContext/v2.0" xmlns:ns3="urn:oasis:names:tc:dss:1.0:core:schema" xmlns:ns4="http://ws.gematik.de/conn/SignatureService/v7.4" xmlns:ns5="http://www.w3.org/2000/09/xmldsig#" xmlns:ns6="http://ws.gematik.de/tel/error/v2.0" xmlns:ns7="http://uri.etsi.org/01903/v1.3.2#" xmlns:ns8="http://ws.gematik.de/conn/CertificateServiceCommon/v2.0" xmlns:ns9="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:ns10="http://www.w3.org/2001/04/xmlenc#" xmlns:ns11="http://uri.etsi.org/02231/v2#" xmlns:ns12="urn:oasis:names:tc:dss-x:1.0:profiles:verificationreport:schema#" xmlns:ns13="urn:oasis:names:tc:dss-x:1.0:profiles:SignaturePolicy:schema#" xmlns:ns14="urn:oasis:names:tc:SAML:2.0:assertion">
      <Status>
        <Result>OK</Result>
      </Status>
      <ns3:SignatureObject>
        <ns3:Base64Signature Type="urn:ietf:rfc:3447">N9Ut1Jepp-p77Vu2sOca3FqyiqDPYWKd6N4HO82YazWlg61uVwE49eRntsfSdx8HpGNdY9CerkARRCYAYJSqSw</ns3:Base64Signature> <1>
      </ns3:SignatureObject>
    </ns4:ExternalAuthenticateResponse>
  </soap:Body>
</soap:Envelope>
----
<1> Dieses Element enthält die Signatur, die mittels Konnektor und dem privaten Schlüssel der SMC-B erstellt wurde.

[cols="a,a"] 
|===
|Code   |Type Success  
|200  | OK +
[small]#Die Anfrage wurde erfolgreich bearbeitet. Die angeforderte Ressource wurde vor dem Senden der Antwort erstellt.#
|Code   |Type Error   
|400  | Bad Request  +
[small]#Die Anfrage-Nachricht war fehlerhaft aufgebaut.#
|===


== Für Versicherte mit ihren Smartphones
*Nutzung der Gesundheitskarte* +
Versicherte können sich gegenüber der Telematikinfrastruktur mit der Identität der elektronischen Gesundheitskarte ausweisen.
Der Ablauf ist analog zu dem oben ausgeführt Ablauf für Primärsysteme. Das E-Rezept-FdV bündelt dabei (wie das Primärsystem) in Stufe 1 die E-Rezept-Fachlogik und die Funktion des Authenticator-Moduls. Die Signatur der Challenge erfolgt bei Nutzung der elektronischen Gesundheitskarte bspw. über die NFC-Schnittstelle des Mobilgeräts.
Dabei wird das Schlüsselmaterial PRK.CH.AUT für Private-Key und C.CH.AUT für das Zertifikat inkl. PublicKey verwendet.


= Verschlüsselter Transportkanal zur Vertrauenswürdigen Ausführungsumgebung ("VAU-Transport")
Der Einsatz moderner Transportverschlüsselung ab TLS 1.2 schützt vor der Einsicht sensibler Daten beim Transport über das Internet. Dabei sind sowohl die Daten des HTTP-Body als auch die aufgerufene URL und die HTTP-Header verschlüsselt. In modernen Cloud-Infrastrukturen enden solche TLS-Verbindungen meist an einem Internetgateway, müssen jedoch in einer Serverinfrastruktur häufig zu dahinterliegenden Applicationservern und -diensten weitertransportiert werden. 

Um sensible Daten bis hinein in einen vertrauenswürdigen Ausführungskontext verschlüsselt zu transportieren, erfolgt der Zugang zum E-Rezept-Fachdienst mit einer zusätzlichen Transportverschlüsselung für eine kryptografische Identität der vertrauenswürdigen Ausführungsumgebung (VAU). Dabei werden die Daten des HTTP-Body für den Verarbeitungskontext der VAU  um einen symmetrischen Antwortschlüssel ergänzt und anschließend asymmetrisch verschlüsselt. Dieser verschlüsselte HTTP-Request wird dann mittels TLS transportverschlüsselt an den E-Rezept-Fachdienst übergeben. 

image:api_vau_transport.png[width=80%]

NOTE: Das Diagramm inkl. der konkreten Ablaufbeschreibung befindet sich auch im Spezifikationsdokument [gemSpec_Krypt] in Kapitel 7.

Die VAU des E-Rezept-Fachdienstes erzeugt eine HTTP-Response entsprechend des Workflows im E-Rezept und verschlüsselt diese Response symmetrisch mit dem vom Client bereitgestellten Antwortschlüssel. Die verschlüsselte Response wird anschließend mittels TLS transportverschlüsselt an den Client zurückgegeben.

Ein zusätzlich in den Aufrufen vom E-Rezept-Fachdienst generiertes, wechselndes Nutzerpseudonym wirkt zusätzlich Überlastungsangriffen entgegen, indem Aufrufe ohne Nutzerpseudonym mit einer geringeren Priorität bearbeitet werden.

== Verbindungsaufbau zum E-Rezept-Fachdienst
Zunächst muss das Verschlüsselungszertifikat der VAU vom E-Rezept-Fachdienst abgerufen werden. 

[cols="h,a"] 
|===
|URI        |https://prescriptionserver.telematik/VAUCertificate
|Method     |GET
|HTTP Header |-
|Payload    | -
|Response |
[source,json]
----
HTTP/1.1 200 OK
Content-Type: application/pkix-cert 

1100110001111111000000011011000010100111100001111000010010111001...
----
|===

Der E-Rezept-Fachdienst stellt zusätzlich eine frische OCSP-Response für die erweiterte Prüfung des Verschlüsselungszertifikats bereit.

[cols="h,a"] 
|===
|URI        |https://prescriptionserver.telematik/VAUCertificateOCSPResponse
|Method     |GET
|HTTP Header |-
|Payload    | -
|Response |
[source,json]
----
HTTP/1.1 200 OK
Content-Type: application/ocsp-response 

100100100110001011110001110111011000110000101111101100100111011...
----
|===

== Request versenden
Für den verschlüsselten VAU-Transport wird der zu transportierende HTTP-Request für die VAU in mehreren Schritten aufbereitet. Als Beispiel wird im Folgenden die Abfrage aller E-Rezepte eines Versicherten verwendet.
[source,json]
----
GET /Task HTTP/1.1
Host: prescriptionserver.telematik
Authorization: Bearer eyJraWQ.ewogImL2pA10Qql22ddtutrvx4FsDlz.rHQjEmB1lLmpqn9J
User-Agent: E-Rezept FdV 1.0.0
Accept: application/fhir+json;charset=utf-8
----
Zunächst müssen im Client eine zufällige Request-ID (z.B. `b69f01734f34376ddcdbdbe9af18a06f`) und ein symmetrischer Antwortschlüssel (z.B. `16bac90134c635e4ec85fae0e4885d9f`) generiert werden. +
Als nächstes wird die folgende leerzeichengetrennte Zeichenkette `p` für die anschließende Verschlüsselung gebildet: `p="1" + " " + ACCESS_TOKEN + " " + Request-ID + " " + Antwortschlüssel + " " + HTTP-Request`, mit obigem Beispiel ergibt sich für `p`:
[source,json]
----
"1 eyJraWQ.ewogImL2pA10Qql22ddtutrvx4FsDlz.rHQjEmB1lLmpqn9J b69f01734f34376ddcdbdbe9af18a06f 16bac90134c635e4ec85fae0e4885d9f GET /Task HTTP/1.1
Host: prescriptionserver.telematik
Authorization: Bearer eyJraWQ.ewogImL2pA10Qql22ddtutrvx4FsDlz.rHQjEmB1lLmpqn9J
User-Agent: E-Rezept FdV 1.0.0
Accept: application/fhir+json;charset=utf-8"
----
Diese Zeichenkette wird nun mit dem ECIES-Verfahrens [SEC1-2009] und dem öffentlichen Schlüssel aus dem zuvor abgerufenen Verschlüsselungszertifikat der VAU hybrid verschlüsselt. Sei `1101110011011110000101101000111000010101100110111011111100011111111110001101110010011010010110000101000001011000000100` ein unvollständiges Beispiel für das Ergebnis der Verschlüsselungsoperation. Dieses wird nun als Payload im HTTP-Body des folgenden Requests an den E-Rezept-Fachdienst übergeben.

[cols="h,a"] 
|===
|URI        |https://prescriptionserver.telematik/VAU/0
|Method     |POST
|HTTP Header |`Content-Type: application/octet-stream` 
|HTTP Body   |`1101110011011110000101101000111000010101100110111011111100011111111110001101110010011010010110000101000001011000000100`
|Response |
[source,json]
----
HTTP/1.1 200 OK
Content-Type: application/octet-stream
Userpseudonym: 270810c79748768a9b0aefbf52c8d72be7ad5e0d2d328d9bb70dbf58623fc7ae

001111101111100110001001001111010110010010111110101100100011110...
----
|===
NOTE: Die `0` am Ende der URL des Requests steht für ein (dem Client nicht bekanntes) Nutzerpseudonym, nach der ersten Antwort der VAU des E-Rezept-Fachdienstes kann das vom Fachdienst mitgeteilte `Userpseudonym` `270810c79748768a9b0aefbf52c8d72be7ad5e0d2d328d9bb70dbf58623fc7ae` anstelle der `0` verwendet werden, um Folgezugriffe höher zu priorisieren.


== Response verarbeiten
Nach dem erfolgreichen Abschluss der Bearbeitung des Requests durch die VAU des E-Rezept-Fachdienstes erhält der Client die verschlüsselte HTTP-Response der VAU in einer äußeren "VAU-Transport"-HTTP-Response.
Der HTTP-Statuscode 200 signalisiert dabei die korrekte Verarbeitung und Erstellung der verschlüsselten Antwort. Die innere HTTP-Response des fachlichen Ergebnisses aus der VAU kann dabei einen abweichenden HTTP-Statuscode beinhalten, wenn aufgrund der Daten oder Verarbeitung innerhalb der VAU Fehlerzustände eintreten oder ungültige Daten übergeben wurden. Sei `001111101111100110001001001111010110010010111110101100100011110...` die verschlüsselte Response zum obigen Beispiel. Die Entschlüsselung mit dem für den Request generierten Antwortschlüssel `16bac90134c635e4ec85fae0e4885d9f`mittels AES-GCM liefert die innere HTTP-Response der VAU als leerzeichengetrennte Zeichenkette:
[source,json]
----
1 b69f01734f34376ddcdbdbe9af18a06f HTTP/1.1 200 OK
Content-Type: application/fhir+json;charset=utf-8
Content-Location: https://prescriptionserver.telematik/Bundle/f5ba6eaf-9052-42f6-ac4e-fadceed7293b

{
  "resourceType": "Bundle",
  "id": "f5ba6eaf-9052-42f6-ac4e-fadceed7293b",
  "meta": {
    "lastUpdated": "2020-03-01T07:02:37.836+00:00"
  },
  "type": "searchset",
  "total": 2,
  "link": [{
    "relation": "self",
    "url": "https://prescriptionserver.telematik/Task/"
  }],
  "entry": [{
    "fullUrl": "https://prescriptionserver.telematik/Task/588780",    
    "resource": {
      "resourceType": "Task",
      "id":"588780",
      "meta": {
        "profile":  [
            "https://gematik.de/fhir/StructureDefinition/ErxTask"
        ]
      },
      "extension":  [{
        "url": "https://gematik.de/fhir/StructureDefinition/PrescriptionType",
        "valueCoding": {
          "system": "https://gematik.de/fhir/CodeSystem/Flowtype",
          "code": "160",
          "display": "Muster 16 (Apothekenpflichtige Arzneimittel)"
        }
      }, {
        "url": "https://gematik.de/fhir/StructureDefinition/AcceptDate",
        "valueDateTime": "2020-03-02T08:25:05+00:00"
      }, {
        "url": "https://gematik.de/fhir/StructureDefinition/ExpiryDate",
        "valueDateTime": "2020-05-02T08:25:05+00:00"
      }],
      "identifier":  [{
        "system": "https://gematik.de/fhir/NamingSystem/PrescriptionID",
        "value": "160.123.456.789.123.58"
      }, {
        "system": "https://gematik.de/fhir/NamingSystem/AccessCode",
        "value": "777bea0e13cc9c42ceec14aec3ddee2263325dc2c6c699db115f58fe423607ea"
      }, {
        "system": "https://gematik.de/fhir/NamingSystem/Secret",
        "value": "c36ca26502892b371d252c99b496e31505ff449aca9bc69e231c58148f6233cf"
      }],
      "status": "in-progress",
      "intent": "order",
      "for": {
        "identifier": {
          "system": "http://fhir.de/NamingSystem/gkv/kvid-10",
          "value": "X123456789"
        }
      },
      "authoredOn": "2020-03-02T08:25:05+00:00",
      "lastModified": "2020-03-02T08:45:05+00:00",
      "performerType":  [{
        "coding":  [{
          "system": "urn:ietf:rfc:3986",
          "code": "urn:oid:1.2.276.0.76.4.54",
          "display": "Öffentliche Apotheke"
        }]
      }],
      "input":  [{
        "type": {
          "coding":  [{
            "system": "https://gematik.de/fhir/CodeSystem/Documenttype",
            "code": "1",
            "display": "Health Care Provider Prescription"
          }]
        },
        "valueReference": {
          "reference": "Bundle/KbvPrescriptionExample"
        }
      }]
    },
    "search": {
      "mode": "match"
    }
  }]
}
----

NOTE: Die innere HTTP-Response hat die folgende Struktur "1" + " " + ursprüngliche-Request-ID + " " + Response-Header-und-Body

WARNING: Ein Splitten der inneren Struktur anhand des Leerzeichens " " könnte dazu führen, dass auch der Payload im inneren HTTP-Response-Body zerstückelt wird. Robuster ist das Prüfen auf Vorhandensein der ursprünglichen Request-ID und anschließendes Entfernen des von der VAU hinzugefügten Präfixes `"1" + " " + ursprüngliche-Request-ID + " "`. Nun kann die innere HTTP-Response standardgemäß weiterverarbeitet werden.


